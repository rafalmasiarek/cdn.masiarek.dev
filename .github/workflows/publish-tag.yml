name: "Pages: Publish Package Release"

on:
  workflow_run:
    workflows: ["Release: Bump & Tag"]
    types: [completed]

  # optional manual publish
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag to publish (e.g. vinyl-loader@1.1.1)"
        required: true
        type: string

permissions:
  contents: write

concurrency:
  group: gh-pages
  cancel-in-progress: false

jobs:
  publish:
    # Only run automatically if the triggering workflow succeeded
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout source (the release commit)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # When triggered by workflow_run, publish exactly the commit that produced the tag
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Fetch tags
        run: |
          set -euo pipefail
          git fetch --tags --force

      - name: Resolve tag to publish
        id: tag
        run: |
          set -euo pipefail

          # 1) Manual publish => use input tag
          TAG="${{ inputs.tag }}"
          if [[ -n "$TAG" ]]; then
            echo "Using manually provided tag: $TAG"
          else
            # 2) workflow_run => pick tag that points at this exact commit
            SHA="${{ github.event.workflow_run.head_sha || github.sha }}"
            TAG="$(git tag --points-at "$SHA" | grep -E '.+@.+' | sort -V | tail -n 1 || true)"

            if [[ -z "$TAG" ]]; then
              # 3) Fallback: pick latest tag in repo matching *@*
              TAG="$(git tag --list '*@*' | sort -V | tail -n 1 || true)"
            fi
          fi

          if [[ -z "$TAG" ]]; then
            echo "Could not resolve a tag to publish."
            exit 1
          fi

          if [[ "$TAG" != *"@"* ]]; then
            echo "Invalid tag '$TAG'. Expected: <package>@<version>"
            exit 1
          fi

          PKG="${TAG%@*}"
          VER="${TAG#*@}"

          echo "Resolved publish tag: $TAG"
          echo "pkg=$PKG" >> $GITHUB_OUTPUT
          echo "ver=$VER" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT

      - name: Validate package exists
        run: |
          set -euo pipefail
          PKG="${{ steps.tag.outputs.pkg }}"
          test -d "packages/$PKG" || (echo "Package '$PKG' not found under packages/." && exit 1)

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Build package
        run: |
          set -euo pipefail
          PKG="${{ steps.tag.outputs.pkg }}"
          cd "packages/$PKG"
          npm install --no-audit --no-fund
          npm run build

      - name: Checkout gh-pages into ./public (create if missing)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          rm -rf public
          mkdir -p public
          cd public

          git init
          git remote add origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"

          if git fetch origin gh-pages --depth 1; then
            git checkout -B gh-pages FETCH_HEAD
          else
            git checkout --orphan gh-pages
            git rm -rf . >/dev/null 2>&1 || true
            mkdir -p _index
            echo "gh-pages initialized" > _index/.init
          fi

          mkdir -p _index
          touch .nojekyll

      - name: Publish dist + manifests + indexes + UI
        env:
          PKG: ${{ steps.tag.outputs.pkg }}
          VER: ${{ steps.tag.outputs.ver }}
          SHA: ${{ github.event.workflow_run.head_sha || github.sha }}
          CDN_BASE_URL: ${{ vars.CDN_BASE_URL }}
          CDN_CUSTOM_DOMAIN: ${{ vars.CDN_CUSTOM_DOMAIN }}
        run: |
          set -euo pipefail

          if [[ "$VER" == *"-"* ]]; then
            CHANNEL="beta"
          else
            CHANNEL="stable"
          fi

          BUILT_AT="$(date -u +%FT%TZ)"
          PKG_DIR="public/$PKG"
          VERSION_DIR="$PKG_DIR/v$VER"
          LATEST_DIR="$PKG_DIR/@latest"
          STABLE_DIR="$PKG_DIR/@stable"
          BETA_DIR="$PKG_DIR/@beta"

          mkdir -p "$VERSION_DIR" "$LATEST_DIR" "$STABLE_DIR" "$BETA_DIR" "public/_index"

          # Copy dist -> versioned folder (immutable)
          rm -rf "$VERSION_DIR"/*
          cp -r "packages/$PKG/dist/"* "$VERSION_DIR/"

          # Update @latest always
          rm -rf "$LATEST_DIR"/*
          cp -r "packages/$PKG/dist/"* "$LATEST_DIR/"

          # Update channel pointers
          if [[ "$CHANNEL" == "stable" ]]; then
            rm -rf "$STABLE_DIR"/*
            cp -r "packages/$PKG/dist/"* "$STABLE_DIR/"
          else
            rm -rf "$BETA_DIR"/*
            cp -r "packages/$PKG/dist/"* "$BETA_DIR/"
          fi

          # Manifest with SRI
          node -e "import {computeSriMap} from './tools/sri.mjs'; import fs from 'node:fs';
          const files = computeSriMap('$VERSION_DIR');
          const manifest = {
            package: process.env.PKG,
            version: 'v' + process.env.VER,
            channel: '$CHANNEL',
            built_at: '$BUILT_AT',
            commit: process.env.SHA,
            files
          };
          fs.writeFileSync('$VERSION_DIR/manifest.json', JSON.stringify(manifest, null, 2)+'\\n');
          fs.writeFileSync('$LATEST_DIR/manifest.json', JSON.stringify(manifest, null, 2)+'\\n');
          if ('$CHANNEL'==='stable') fs.writeFileSync('$STABLE_DIR/manifest.json', JSON.stringify(manifest, null, 2)+'\\n');
          if ('$CHANNEL'==='beta') fs.writeFileSync('$BETA_DIR/manifest.json', JSON.stringify(manifest, null, 2)+'\\n');
          "

          # Index updates
          node -e "import {updateIndexes} from './tools/update-index.mjs';
          updateIndexes({ publicDir: 'public', pkg: process.env.PKG, version: 'v' + process.env.VER, channel: '$CHANNEL', builtAt: '$BUILT_AT' });"

          node -e "import {buildBundleManifest} from './tools/build-bundle-manifest.mjs';
          buildBundleManifest({ publicDir: 'public', baseUrl: process.env.CDN_BASE_URL || '', builtAt: '$BUILT_AT' });"

          # Pages UI
          cp -f pages/index.html public/index.html
          cp -f pages/app.js public/app.js
          cp -f pages/styles.css public/styles.css

          touch public/.nojekyll

          # Custom domain for GitHub Pages (optional)
          if [[ -n "${CDN_CUSTOM_DOMAIN:-}" ]]; then
            echo "${CDN_CUSTOM_DOMAIN}" > public/CNAME
          fi

      - name: Commit & push
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          cd public

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add -A
          git commit -m "pages(pkg): ${{ steps.tag.outputs.tag }}" || true
          git push -u origin gh-pages

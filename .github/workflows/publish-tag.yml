name: "Pages: Publish Package Release"

on:
  workflow_run:
    workflows: ["Release: Bump & Tag"]
    types: [completed]

  # optional manual publish
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag to publish (e.g. vinyl-loader@1.1.1)"
        required: true
        type: string

permissions:
  contents: write
  actions: write

jobs:
  publish:
    # Only run automatically if the triggering workflow succeeded
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout source (the release commit)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # When triggered by workflow_run, publish exactly the commit that produced the tag
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Fetch tags
        run: |
          set -euo pipefail
          git fetch --tags --force

      - name: Resolve tag to publish
        id: tag
        run: |
          set -euo pipefail

          # 1) Manual publish => use input tag
          TAG="${{ inputs.tag }}"
          if [[ -n "$TAG" ]]; then
            echo "Using manually provided tag: $TAG"
          else
            # 2) workflow_run => pick tag that points at this exact commit
            SHA="${{ github.event.workflow_run.head_sha || github.sha }}"
            TAG="$(git tag --points-at "$SHA" | grep -E '.+@.+' | sort -V | tail -n 1 || true)"

            if [[ -z "$TAG" ]]; then
              # 3) Fallback: pick latest tag in repo matching *@*
              TAG="$(git tag --list '*@*' | sort -V | tail -n 1 || true)"
            fi
          fi

          if [[ -z "$TAG" ]]; then
            echo "Could not resolve a tag to publish."
            exit 1
          fi

          if [[ "$TAG" != *"@"* ]]; then
            echo "Invalid tag '$TAG'. Expected: <package>@<version>"
            exit 1
          fi

          PKG="${TAG%@*}"
          VER="${TAG#*@}"

          echo "Resolved publish tag: $TAG"
          echo "pkg=$PKG" >> $GITHUB_OUTPUT
          echo "ver=$VER" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT

      - name: Validate package exists
        run: |
          set -euo pipefail
          PKG="${{ steps.tag.outputs.pkg }}"
          test -d "packages/$PKG" || (echo "Package '$PKG' not found under packages/." && exit 1)

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Build package
        run: |
          set -euo pipefail
          PKG="${{ steps.tag.outputs.pkg }}"
          cd "packages/$PKG"
          npm install --no-audit --no-fund
          npm run build

      - name: Checkout gh-pages into ./public (create if missing)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          rm -rf public
          mkdir -p public
          cd public

          git init
          git remote add origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"

          if git fetch origin gh-pages --depth 1; then
            git checkout -B gh-pages FETCH_HEAD
          else
            git checkout --orphan gh-pages
            git rm -rf . >/dev/null 2>&1 || true
            mkdir -p _index
            echo "gh-pages initialized" > _index/.init
          fi

          mkdir -p _index
          touch .nojekyll

      - name: Publish dist + manifests + indexes + UI
        env:
          PKG: ${{ steps.tag.outputs.pkg }}
          VER: ${{ steps.tag.outputs.ver }}
          SHA: ${{ github.event.workflow_run.head_sha || github.sha }}
          CDN_BASE_URL: ${{ vars.CDN_BASE_URL }}
          CDN_CUSTOM_DOMAIN: ${{ vars.CDN_CUSTOM_DOMAIN }}
        run: |
          set -euo pipefail

          PKG="${PKG:?}"
          VER="${VER:?}"

          if [[ "$VER" == *"-"* ]]; then
            CHANNEL="beta"
          else
            CHANNEL="stable"
          fi

          BUILT_AT="$(date -u +%FT%TZ)"
          PKG_DIR="public/$PKG"

          VERSION_DIR="$PKG_DIR/v$VER"
          LATEST_DIR="$PKG_DIR/@latest"
          STABLE_DIR="$PKG_DIR/@stable"
          BETA_DIR="$PKG_DIR/@beta"

          # Channel-scoped aliases (avoid stable/beta collisions)
          STABLE_ALIAS_DIR="$PKG_DIR/stable"
          BETA_ALIAS_DIR="$PKG_DIR/beta"

          mkdir -p \
            "$VERSION_DIR" "$LATEST_DIR" "$STABLE_DIR" "$BETA_DIR" \
            "$STABLE_ALIAS_DIR" "$BETA_ALIAS_DIR" \
            "public/_index"

          # ------------------------------------------------------------
          # Copy dist -> versioned folder (immutable)
          # ------------------------------------------------------------
          rm -rf "$VERSION_DIR"/*
          cp -r "packages/$PKG/dist/"* "$VERSION_DIR/"

          # ------------------------------------------------------------
          # Update @latest always (same content as this publish)
          # ------------------------------------------------------------
          rm -rf "$LATEST_DIR"/*
          cp -r "packages/$PKG/dist/"* "$LATEST_DIR/"

          # ------------------------------------------------------------
          # Update channel pointers
          # ------------------------------------------------------------
          if [[ "$CHANNEL" == "stable" ]]; then
            rm -rf "$STABLE_DIR"/*
            cp -r "packages/$PKG/dist/"* "$STABLE_DIR/"
          else
            rm -rf "$BETA_DIR"/*
            cp -r "packages/$PKG/dist/"* "$BETA_DIR/"
          fi

          # ------------------------------------------------------------
          # Compute major/minor aliases from VER (semver-safe)
          # ------------------------------------------------------------
          node - <<'NODE'
          import semver from "semver";

          const ver = process.env.VER;
          const v = semver.parse(ver);
          if (!v) {
            console.error(`Invalid semver: ${ver}`);
            process.exit(1);
          }

          process.stdout.write(JSON.stringify({
            major: String(v.major),
            minor: String(v.minor),
            majorMinor: `${v.major}.${v.minor}`,
          }));
          NODE

          ALIAS_JSON="$(node - <<'NODE'
          import semver from "semver";
          const ver = process.env.VER;
          const v = semver.parse(ver);
          if (!v) process.exit(1);
          process.stdout.write(JSON.stringify({ major: String(v.major), majorMinor: `${v.major}.${v.minor}` }));
          NODE
          )"

          MAJOR="$(node -p "JSON.parse(process.env.ALIAS_JSON).major" )"
          MAJOR_MINOR="$(node -p "JSON.parse(process.env.ALIAS_JSON).majorMinor" )"

          # Helpers: sync alias dir from dist + manifest
          sync_alias_dir() {
            local dir="$1"
            rm -rf "$dir"
            mkdir -p "$dir"
            cp -r "packages/$PKG/dist/"* "$dir/"
          }

          write_manifest() {
            local dir="$1"
            node -e "import {computeSriMap} from './tools/sri.mjs'; import fs from 'node:fs';
            const files = computeSriMap('$dir');
            const manifest = {
              package: process.env.PKG,
              version: 'v' + process.env.VER,
              channel: '$CHANNEL',
              built_at: '$BUILT_AT',
              commit: process.env.SHA,
              files
            };
            fs.writeFileSync('$dir/manifest.json', JSON.stringify(manifest, null, 2)+'\\n');"
          }

          # ------------------------------------------------------------
          # Manifests for version + pointers
          # ------------------------------------------------------------
          write_manifest "$VERSION_DIR"
          write_manifest "$LATEST_DIR"
          if [[ "$CHANNEL" == "stable" ]]; then
            write_manifest "$STABLE_DIR"
          else
            write_manifest "$BETA_DIR"
          fi

          # ------------------------------------------------------------
          # Channel aliases: /stable/vMAJOR, /stable/vMAJOR.MINOR OR /beta/...
          # ------------------------------------------------------------
          if [[ "$CHANNEL" == "stable" ]]; then
            sync_alias_dir "$STABLE_ALIAS_DIR/v$MAJOR"
            sync_alias_dir "$STABLE_ALIAS_DIR/v$MAJOR_MINOR"
            write_manifest "$STABLE_ALIAS_DIR/v$MAJOR"
            write_manifest "$STABLE_ALIAS_DIR/v$MAJOR_MINOR"

            # Root aliases for stable only: /vMAJOR and /vMAJOR.MINOR
            sync_alias_dir "$PKG_DIR/v$MAJOR"
            sync_alias_dir "$PKG_DIR/v$MAJOR_MINOR"
            write_manifest "$PKG_DIR/v$MAJOR"
            write_manifest "$PKG_DIR/v$MAJOR_MINOR"
          else
            sync_alias_dir "$BETA_ALIAS_DIR/v$MAJOR"
            sync_alias_dir "$BETA_ALIAS_DIR/v$MAJOR_MINOR"
            write_manifest "$BETA_ALIAS_DIR/v$MAJOR"
            write_manifest "$BETA_ALIAS_DIR/v$MAJOR_MINOR"
          fi

          # ------------------------------------------------------------
          # Index updates (only full version goes into versions.json)
          # ------------------------------------------------------------
          node -e "import {updateIndexes} from './tools/update-index.mjs';
          updateIndexes({ publicDir: 'public', pkg: process.env.PKG, version: 'v' + process.env.VER, channel: '$CHANNEL', builtAt: '$BUILT_AT' });"

          node -e "import {buildBundleManifest} from './tools/build-bundle-manifest.mjs';
          buildBundleManifest({ publicDir: 'public', baseUrl: process.env.CDN_BASE_URL || '', builtAt: '$BUILT_AT' });"

          # Pages UI
          cp -f pages/index.html public/index.html
          cp -f pages/app.js public/app.js
          cp -f pages/styles.css public/styles.css

          touch public/.nojekyll

          # Custom domain for GitHub Pages (optional)
          if [[ -n "${CDN_CUSTOM_DOMAIN:-}" ]]; then
            echo "${CDN_CUSTOM_DOMAIN}" > public/CNAME
          fi

      - name: Commit & push
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          cd public

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add -A
          git commit -m "pages(pkg): ${{ steps.tag.outputs.tag }}" || true
          git push -u origin gh-pages
